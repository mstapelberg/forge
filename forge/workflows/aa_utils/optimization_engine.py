#!/usr/bin/env python
"""Script engine for running adversarial attack optimization on a batch of structures.

This script provides two main optimization engines:
1. Gradient-based adversarial attack optimization
2. Monte Carlo based adversarial attack optimization

It is typically invoked via a SLURM script generated by the workflow setup
and processes structures from a specified XYZ file.
"""

import argparse
import json
from pathlib import Path
import ase.io
import numpy as np
from monty.serialization import dumpfn
import sys # Added for exit

# Keep original imports for optimizers and db
# ... existing code ...
from forge.core.adversarial_attack import (
    GradientAdversarialOptimizer,
    AdversarialCalculator,
    DisplacementGenerator,
    AdversarialOptimizer
)
from forge.core.database import DatabaseManager


# --- Variance Calculation Function ---
def calculate_batch_variance(
    xyz_file: str,
    output_json: str,
    model_paths: list[str],
    device: str = "cuda",
    debug: bool = False,
):
    """Calculates force variance for all structures in an XYZ file.

    Args:
        xyz_file: Path to the input XYZ file.
        output_json: Path to save the variance results JSON file.
        model_paths: List of paths to the MACE model files.
        device: Device to run calculations on ('cpu' or 'cuda').
        debug: Enable debug output.
    """
    print(f"[INFO] Starting variance calculation for: {xyz_file}")
    print(f"[INFO] Output JSON: {output_json}")
    print(f"[INFO] Device: {device}")

    output_path = Path(output_json)
    output_path.parent.mkdir(parents=True, exist_ok=True) # Ensure output dir exists

    # Initialize calculator
    try:
        calculator = AdversarialCalculator(
            model_paths=model_paths,
            device=device
        )
    except Exception as e:
        print(f"[ERROR] Failed to initialize AdversarialCalculator: {e}")
        # Write empty results file to signal failure
        with open(output_path, 'w') as f:
            json.dump({}, f)
        sys.exit(1)

    # Load structures
    try:
        atoms_list = ase.io.read(xyz_file, ':')
        print(f"[INFO] Loaded {len(atoms_list)} structures from {xyz_file}")
    except FileNotFoundError:
        print(f"[ERROR] Input XYZ file not found: {xyz_file}")
        with open(output_path, 'w') as f:
            json.dump({}, f)
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] Failed to read XYZ file {xyz_file}: {e}")
        with open(output_path, 'w') as f:
            json.dump({}, f)
        sys.exit(1)

    variance_results = {}
    failed_count = 0

    for i, atoms in enumerate(atoms_list):
        # Use structure_id directly as the key
        struct_id = atoms.info.get('structure_id') 
        if struct_id is None:
             print(f"[WARNING] Structure at index {i} in {xyz_file} is missing 'structure_id' in info. Skipping.")
             failed_count += 1
             continue
             
        # Keep original name for logging if needed, but use ID as key
        #struct_name_log = atoms.info.get('structure_name', f'struct_index_{i}') 
        #if debug: print(f"[DEBUG] Calculating variance for ID: {struct_id} (Name: {struct_name_log})...")

        try:
            # Calculate forces
            forces = calculator.calculate_forces(atoms)
            if forces.size == 0: # Check if force calculation failed
                 print(f"[WARNING] Force calculation failed for structure ID {struct_id}. Skipping.")
                 failed_count += 1
                 continue

            # Calculate variance
            atom_variances = calculator.calculate_normalized_force_variance(forces)
            structure_variance = float(np.mean(atom_variances))

            # Use string representation of struct_id as JSON key
            variance_results[str(struct_id)] = structure_variance 
            if debug: print(f"[DEBUG] Structure ID {struct_id}: Variance = {structure_variance:.6f}")

        except Exception as e:
            print(f"[ERROR] Variance calculation failed for structure ID {struct_id}: {e}")
            if debug:
                import traceback
                traceback.print_exc()
            failed_count += 1
            continue # Skip to next structure

    # Save results to JSON
    try:
        with open(output_path, 'w') as f:
            json.dump(variance_results, f, indent=2)
        print(f"[INFO] Variance results saved to {output_path}")
        if failed_count > 0:
             print(f"[WARNING] Failed to calculate variance for {failed_count} structures.")
    except Exception as e:
        print(f"[ERROR] Failed to write results JSON {output_path}: {e}")


# --- run_gradient_aa_optimization function ---
def run_gradient_aa_optimization(
    xyz_file: str,
    output_dir: str,
    model_paths: list[str],
    learning_rate: float = 0.01,
    n_iterations: int = 60,
    min_distance: float = 1.5,
    include_probability: bool = False,
    temperature: float = 0.86, # Temp for probability weighting (eV)
    device: str = "cuda",
    use_autograd: bool = False, # This likely needs specific MACE versions/forks
    debug: bool = False,
    save_trajectory: bool = True, # Added parameter
):
    """Run gradient-based adversarial attack optimization on structures in XYZ file.

    This function iterates through structures in an XYZ file, applying gradient
    ascent to maximize the variance of forces predicted by an ensemble of models.
    Results (optimized structures, trajectories, summary) are saved to the output directory.

    Args:
        xyz_file: Path to input XYZ file containing structures.
        output_dir: Directory to save optimization results (trajectories, summary).
        model_paths: List of paths to model files (.model).
        learning_rate: Learning rate for gradient ascent steps.
        n_iterations: Number of optimization iterations.
        min_distance: Minimum allowed distance between atoms (Ã…) during optimization.
        include_probability: Whether to include the Boltzmann probability term in the loss
                             function, biasing towards lower-energy high-variance structures.
                             Requires 'temperature'.
        temperature: Temperature (in eV) used for the probability weighting term.
        device: Device to run calculations on ('cpu' or 'cuda').
        use_autograd: Placeholder for potential future Hessian-based optimizations. Currently unused.
        debug: Whether to print detailed debug messages during optimization.
        save_trajectory: Whether to save the optimization trajectory XYZ file for each structure.
    """
    from forge.core.adversarial_attack import GradientAdversarialOptimizer # Keep local import

    output_path = Path(output_dir)
    results_path = output_path / "aa_results" # Standardized results subfolder
    results_path.mkdir(parents=True, exist_ok=True)

    # Load structures
    try:
        atoms_list = ase.io.read(xyz_file, ':')
        print(f"[INFO] Loaded {len(atoms_list)} structures from {xyz_file}")
    except FileNotFoundError:
        print(f"[ERROR] Input XYZ file not found: {xyz_file}")
        return [] # Return empty list on failure
    except Exception as e:
        print(f"[ERROR] Failed to read XYZ file {xyz_file}: {e}")
        return []

    # Initialize the gradient-based optimizer
    print(f"[INFO] Initializing Gradient Optimizer on device: {device}")
    optimizer = GradientAdversarialOptimizer(
        model_paths=model_paths,
        device=device,
        learning_rate=learning_rate, # Passed during optimize call now
        temperature=temperature,
        include_probability=include_probability,
        debug=debug
    )

    # Run optimization for each structure
    all_results_summary = [] # Changed name for clarity

    for i, atoms in enumerate(atoms_list):
        struct_name = atoms.info.get('structure_name', f'struct_{i}')
        initial_variance = atoms.info.get('initial_variance', None)
        structure_id = atoms.info.get('structure_id', None) # Get ID if present in input

        print(f"\n[INFO] Optimizing structure: {struct_name} (Index: {i}, ID: {structure_id or 'N/A'})")
        if initial_variance:
            print(f"[INFO] Initial variance: {initial_variance:.6f}")

        # Define output directory for this specific structure's trajectory
        struct_traj_dir = results_path / f"{struct_name}_output"
        if save_trajectory:
             struct_traj_dir.mkdir(exist_ok=True)

        # Run optimization
        try:
            # Pass output_dir for trajectory saving inside optimize
            best_atoms, best_loss, loss_history = optimizer.optimize(
                atoms=atoms.copy(), # Use a copy
                n_iterations=n_iterations,
                min_distance=min_distance,
                output_dir=str(struct_traj_dir) if save_trajectory else None, # Pass dir only if saving
            )
        except Exception as e:
            print(f"[ERROR] Optimization failed for structure {struct_name}: {e}")
            if debug:
                import traceback
                traceback.print_exc()
            all_results_summary.append({ # Add failure record
                'structure_name': struct_name,
                'structure_index': i,
                'parent_structure_id': structure_id,
                'status': 'failed',
                'error': str(e)
            })
            continue # Skip to next structure

        # Save final optimized structure to file (always do this)
        optimized_file = results_path / f"{struct_name}_optimized.xyz"
        # --- Populate best_atoms.info before saving ---
        # Use calculated initial variance if not present in input
        calc_initial_variance = loss_history[0] if loss_history else None
        db_initial_variance = initial_variance if initial_variance is not None else calc_initial_variance

        best_atoms.info['initial_variance'] = db_initial_variance
        best_atoms.info['final_variance'] = best_loss # best_loss is the final variance/loss value
        best_atoms.info['optimization_method'] = 'gradient-based'
        # Preserve original name/ID if possible
        best_atoms.info['parent_structure_name'] = atoms.info.get('structure_name', struct_name)
        best_atoms.info['parent_structure_id'] = structure_id # Store the original ID here
        # --- End populating info ---
        ase.io.write(optimized_file, best_atoms, format="extxyz", write_results=True) # Write results to save info dict
        print(f"[INFO] Saved final optimized structure: {optimized_file}")

        # Append to results summary
        calc_initial_variance = loss_history[0] if loss_history else None
        summary_initial_variance = initial_variance if initial_variance is not None else calc_initial_variance

        result_data = {
            'structure_name': struct_name,
            'structure_index': i,
            'parent_structure_id': structure_id, # Original ID from input file/info
            'initial_variance': summary_initial_variance,
            'final_variance': best_loss,
            'loss_history': loss_history,
            'optimized_xyz_file': str(optimized_file.relative_to(output_path)),
            'trajectory_dir': str(struct_traj_dir.relative_to(output_path)) if save_trajectory else None,
            'status': 'success',
        }

        all_results_summary.append(result_data)

    # Save overall summary JSON file
    summary_file = output_path / 'optimization_summary.json'
    summary_data = {
        'input_file': xyz_file,
        'parameters': {
            'method': 'gradient-based',
            'learning_rate': learning_rate,
            'n_iterations': n_iterations,
            'min_distance': min_distance,
            'include_probability': include_probability,
            'temperature': temperature,
            'device': device,
            'use_autograd': use_autograd, # Keep record of parameter passed
            'save_trajectory': save_trajectory,
        },
        'results': all_results_summary # Use the more descriptive name
    }
    dumpfn(summary_data, summary_file, indent=2)
    print(f"[INFO] Optimization summary saved to: {summary_file}")

    return all_results_summary # Return summary list only

# --- run_aa_optimization (Monte Carlo) function ---
# (Add detailed docstring)
def run_aa_optimization(
    xyz_file: str,
    output_dir: str,
    model_paths: list[str],
    temperature: float = 1200.0, # Temp for Metropolis acceptance (K)
    max_steps: int = 50,
    patience: int = 25,
    min_distance: float = 2.0,
    max_displacement: float = 0.1, # Added parameter
    mode: str = "all",
    device: str = "cuda",
    debug: bool = False, # Added debug flag consistency
    save_trajectory: bool = True, # Added parameter
):
    """Run Monte Carlo adversarial attack optimization on structures in XYZ file.

    This function iterates through structures in an XYZ file, applying random
    displacements accepted based on the Metropolis criterion applied to the
    force variance, aiming to maximize model disagreement. Results are saved to files.

    Args:
        xyz_file: Path to input XYZ file containing structures.
        output_dir: Directory to save optimization results (trajectories, summary).
        model_paths: List of paths to model files (.model).
        temperature: Temperature (in K) for the Metropolis acceptance criterion.
                     Higher temperatures allow accepting more variance decreases.
        max_steps: Maximum number of Monte Carlo steps (proposed moves).
        patience: Stop optimization if the maximum variance hasn't increased for
                  this many steps.
        min_distance: Minimum allowed distance between atoms (Ã…) after displacement.
        max_displacement: Maximum distance (Ã…) an atom can be moved in a single step.
        mode: Displacement mode: 'all' (move all atoms) or 'single' (move one atom).
        device: Device to run calculations on ('cpu' or 'cuda').
        debug: Whether to print detailed debug messages during optimization.
        save_trajectory: Whether to save the optimization trajectory XYZ file for each structure.
                         Note: The MC optimizer saves trajectory if output_dir is given.
    """
    output_path = Path(output_dir)
    results_path = output_path / "aa_results" # Standardized results subfolder
    results_path.mkdir(parents=True, exist_ok=True)

    # Initialize calculator, optimizer, and database connection
    print(f"[INFO] Initializing Adversarial Calculator on device: {device}")
    calculator = AdversarialCalculator(
        model_paths=model_paths,
        device=device
    )
    print(f"[INFO] Initializing Displacement Generator: min_dist={min_distance}, max_disp={max_displacement}")
    # Pass max_displacement to the generator
    displacement_gen = DisplacementGenerator(min_distance=min_distance) # Removed max_displacement from generator init, it's handled inside AdversarialOptimizer now

    print("[INFO] Initializing Monte Carlo Optimizer")
    optimizer = AdversarialOptimizer(
        adversarial_calc=calculator,
        displacement_gen=displacement_gen,
    )

    # Load structures
    try:
        atoms_list = ase.io.read(xyz_file, ':')
        print(f"[INFO] Loaded {len(atoms_list)} structures from {xyz_file}")
    except FileNotFoundError:
        print(f"[ERROR] Input XYZ file not found: {xyz_file}")
        return []
    except Exception as e:
        print(f"[ERROR] Failed to read XYZ file {xyz_file}: {e}")
        return []

    # Run optimization for each structure
    all_results_summary = [] # Changed name

    for i, atoms in enumerate(atoms_list):
        struct_name = atoms.info.get('structure_name', f'struct_{i}')
        initial_variance = atoms.info.get('initial_variance', None)
        structure_id = atoms.info.get('structure_id', None)

        print(f"\n[INFO] Optimizing structure: {struct_name} (Index: {i}, ID: {structure_id or 'N/A'})")
        if initial_variance:
            print(f"[INFO] Initial variance: {initial_variance:.6f}")

        # Define output directory for this specific structure's trajectory etc.
        # The optimizer internally uses this path to save trajectory and summary snippet
        struct_output_path = results_path / f"{struct_name}_output"
        struct_output_path.mkdir(exist_ok=True)

        # Run optimization
        try:
            # Pass output_dir to enable trajectory saving within optimizer
            # Also pass save_trajectory flag if optimizer supports it explicitly (check needed)
            # Current AdversarialOptimizer saves traj if output_dir is not None.
            # It also saves a summary snippet there.
            best_atoms, best_variance, accepted_moves = optimizer.optimize(
                atoms=atoms.copy(), # Use a copy
                temperature=temperature,
                max_iterations=max_steps,
                patience=patience,
                mode=mode,
                output_dir=str(struct_output_path) if save_trajectory else None, # Pass dir only if saving
            )
            print(f"[INFO] Optimization complete. Final variance: {best_variance:.6f}, Accepted moves: {accepted_moves}")

        except Exception as e:
            print(f"[ERROR] Optimization failed for structure {struct_name}: {e}")
            if debug:
                import traceback
                traceback.print_exc()
            all_results_summary.append({ # Add failure record
                 'structure_name': struct_name,
                 'structure_index': i,
                 'input_structure_id': structure_id,
                 'status': 'failed',
                 'error': str(e)
             })
            continue # Skip to next structure

        # Save final optimized structure to file (always do this)
        optimized_file = results_path / f"{struct_name}_optimized.xyz"
        # --- Populate best_atoms.info before saving ---
        # Calculate initial variance if not provided
        forces = calculator.calculate_forces(atoms) # Need initial forces
        calc_initial_variance = float(np.mean(calculator.calculate_normalized_force_variance(forces))) if forces.size > 0 else None
        db_initial_variance = initial_variance if initial_variance is not None else calc_initial_variance

        best_atoms.info['initial_variance'] = db_initial_variance
        best_atoms.info['final_variance'] = best_variance
        best_atoms.info['optimization_method'] = 'monte-carlo'
        best_atoms.info['parent_structure_name'] = atoms.info.get('structure_name', struct_name)
        best_atoms.info['parent_structure_id'] = structure_id
        best_atoms.info['accepted_moves'] = accepted_moves
        # --- End populating info ---
        ase.io.write(optimized_file, best_atoms, format="extxyz", write_results=True) # Write results to save info dict
        print(f"[INFO] Saved final optimized structure: {optimized_file}")
        if save_trajectory:
             # Trajectory is saved by optimizer inside struct_output_path
             print(f"[INFO] Trajectory and step summary saved in: {struct_output_path}")

        # Append to results summary
        calc_initial_variance = float(np.mean(calculator.calculate_normalized_force_variance(forces))) if forces.size > 0 else None
        summary_initial_variance = initial_variance if initial_variance is not None else calc_initial_variance

        result_data = {
            'structure_name': struct_name,
            'structure_index': i,
            'input_structure_id': structure_id,
            'initial_variance': summary_initial_variance,
            'final_variance': best_variance,
            'accepted_moves': accepted_moves,
            'optimized_xyz_file': str(optimized_file.relative_to(output_path)),
            'trajectory_dir': str(struct_output_path.relative_to(output_path)) if save_trajectory else None,
            'status': 'success',
        }

        all_results_summary.append(result_data)

    # Save overall summary JSON file
    summary_file = output_path / 'optimization_summary.json'
    summary_data = {
        'input_file': xyz_file,
        'parameters': {
            'method': 'monte-carlo',
            'temperature': temperature, # Metropolis temperature
            'max_steps': max_steps,
            'patience': patience,
            'min_distance': min_distance,
            'max_displacement': max_displacement,
            'mode': mode,
            'device': device,
            'save_trajectory': save_trajectory,
        },
        'results': all_results_summary
    }
    dumpfn(summary_data, summary_file, indent=2)
    print(f"[INFO] Optimization summary saved to: {summary_file}")

    return all_results_summary # Return summary list only

# --- REMOVE VASP Job Creation ---
# def create_vasp_jobs_from_aa_results(...): # REMOVED
# ... function content removed ...

# --- Main execution block ---
def main():
    parser = argparse.ArgumentParser(
        description="Run adversarial attack optimization or variance calculation." # Updated description
    )

    # --- Arguments for selecting the mode ---
    mode_group = parser.add_argument_group('Mode Selection')
    mode_group.add_argument(
        "--calculate_variance",
        action="store_true",
        help="Run variance calculation instead of AA optimization."
    )
    mode_group.add_argument(
        "--gradient",
        action="store_true",
        help="Use gradient-based AA optimization (default is Monte Carlo if not --calculate_variance)."
    )

    # --- Common arguments for all modes ---
    common_group = parser.add_argument_group('Common Arguments')
    common_group.add_argument(
        "xyz_file",
        help="Input XYZ file containing structures."
    )
    common_group.add_argument(
        "--model_dir",
        required=True,
        help="Directory containing MACE *.model files for the ensemble."
    )
    common_group.add_argument(
        "--device",
        choices=['cpu', 'cuda'],
        default='cuda',
        help="Device to run calculations on ('cpu' or 'cuda'). Default: cuda"
    )
    common_group.add_argument(
        "--debug",
        action="store_true",
        help="Enable detailed debug messages."
    )

    # --- Arguments specific to Variance Calculation ---
    var_group = parser.add_argument_group('Variance Calculation Arguments')
    var_group.add_argument(
        "--output_json",
        help="Output JSON file path for variance results (--calculate_variance mode)."
    )

    # --- Arguments specific to AA Optimization ---
    aa_group = parser.add_argument_group('Adversarial Attack Optimization Arguments')
    aa_group.add_argument(
        "output_dir", # Made conditional later
        nargs='?', # Make output_dir optional initially
        help="Output directory for AA optimization results (Required unless --calculate_variance)."
    )
    aa_group.add_argument(
        "--min_distance",
        type=float,
        # Default depends on method, handle below
        help="Minimum allowed distance between atoms (Ã…) during AA."
    )
    aa_group.add_argument(
        "--save_trajectory",
        action=argparse.BooleanOptionalAction, # Creates --save-trajectory/--no-save-trajectory
        default=True,
        help="Save the AA optimization trajectory."
    )
    # Parameters for Gradient optimization
    grad_group = parser.add_argument_group('Gradient AA Arguments')
    grad_group.add_argument(
        "--learning_rate",
        type=float,
        default=0.01,
        help="Learning rate for gradient ascent (--gradient mode)."
    )
    grad_group.add_argument(
        "--n_iterations",
        type=int,
        default=60,
        help="Number of optimization iterations (--gradient mode)."
    )
    grad_group.add_argument(
        "--include_probability",
        action="store_true",
        help="Include probability term in adversarial loss (--gradient mode)."
    )
    grad_group.add_argument(
        "--use_autograd", # Keep for consistency, even if unused for now
        action="store_true",
        help="Placeholder for Hessian-based gradient calculation (--gradient mode)."
    )
    # Temperature has different meanings, handle based on mode
    aa_group.add_argument( # Temperature applies to both AA modes
        "--temperature",
        type=float,
        # Default depends on method, handle below
        help="Temperature for optimization: Metropolis (K) for MC, probability weighting (eV) for gradient."
    )
    # Parameters for Monte Carlo optimization
    mc_group = parser.add_argument_group('Monte Carlo AA Arguments')
    mc_group.add_argument(
        "--max_steps",
        type=int,
        default=50,
        help="Maximum optimization steps per structure (MC mode)."
    )
    mc_group.add_argument(
        "--patience",
        type=int,
        default=25,
        help="Stop if no improvement after this many steps (MC mode)."
    )
    mc_group.add_argument(
        "--max_displacement", # Added
        type=float,
        default=0.1,
        help="Maximum distance an atom can be moved in a single step (Ã…) (MC mode)."
    )
    mc_group.add_argument(
        "--mode",
        choices=['all', 'single'],
        default='all',
        help="Atom displacement mode ('all' or 'single') (MC mode)."
    )


    args = parser.parse_args()

    # --- Validate arguments based on mode ---
    if args.calculate_variance:
        if not args.output_json:
            parser.error("--output_json is required when using --calculate_variance.")
        if args.output_dir:
             print("[WARNING] output_dir argument is ignored when using --calculate_variance.")
        # Cannot run AA and variance calculation simultaneously
        if args.gradient or args.max_steps != 50: # Check if other AA flags were set
             print("[WARNING] AA optimization flags (--gradient, etc.) are ignored when using --calculate_variance.")
    else: # AA Optimization mode
        if not args.output_dir:
             parser.error("output_dir (positional argument) is required unless --calculate_variance is used.")
        if args.output_json:
             print("[WARNING] --output_json argument is ignored when running AA optimization.")

    # --- Get model paths (common to all modes) ---
    model_dir_path = Path(args.model_dir)
    if not model_dir_path.is_dir():
        print(f"[ERROR] Model directory not found: {args.model_dir}")
        sys.exit(1)
    model_paths = [str(p) for p in model_dir_path.glob("*.model")]
    if not model_paths:
        print(f"[ERROR] No *.model files found in {args.model_dir}")
        sys.exit(1)
    print(f"[INFO] Using {len(model_paths)} models from {args.model_dir}")


    # --- Execute selected mode ---
    try:
        if args.calculate_variance:
            print(f"[INFO] Running Variance Calculation")
            print(f"[INFO] Input structures: {args.xyz_file}")
            calculate_batch_variance(
                 xyz_file=args.xyz_file,
                 output_json=args.output_json,
                 model_paths=model_paths,
                 device=args.device,
                 debug=args.debug,
            )
            print("[INFO] Variance calculation finished successfully.")

        else: # AA Optimization Mode
            # --- Set method-specific defaults if not provided ---
            if args.gradient:
                min_distance = args.min_distance if args.min_distance is not None else 1.5
                temperature = args.temperature if args.temperature is not None else 0.86 # eV default for gradient probability
                method_name = "Gradient-Based"
            else: # Monte Carlo
                min_distance = args.min_distance if args.min_distance is not None else 2.0
                temperature = args.temperature if args.temperature is not None else 1200.0 # K default for MC Metropolis
                method_name = "Monte Carlo"

            print(f"[INFO] Running {method_name} Adversarial Attack")
            print(f"[INFO] Input structures: {args.xyz_file}")
            print(f"[INFO] Output directory: {args.output_dir}")
            print(f"[INFO] Device: {args.device}, Min distance: {min_distance}")

            if args.gradient:
                run_gradient_aa_optimization(
                    xyz_file=args.xyz_file,
                    output_dir=args.output_dir,
                    model_paths=model_paths,
                    learning_rate=args.learning_rate,
                    n_iterations=args.n_iterations,
                    min_distance=min_distance,
                    include_probability=args.include_probability,
                    temperature=temperature, # eV
                    device=args.device,
                    use_autograd=args.use_autograd,
                    debug=args.debug,
                    save_trajectory=args.save_trajectory,
                )
            else: # Monte Carlo
                run_aa_optimization(
                    xyz_file=args.xyz_file,
                    output_dir=args.output_dir,
                    model_paths=model_paths,
                    temperature=temperature, # K
                    max_steps=args.max_steps,
                    patience=args.patience,
                    min_distance=min_distance,
                    max_displacement=args.max_displacement, # Pass this arg
                    mode=args.mode,
                    device=args.device,
                    debug=args.debug,
                    save_trajectory=args.save_trajectory,
                )
            print("[INFO] Optimization engine finished successfully.")

    except Exception as e:
        print(f"\\n[ERROR] An critical error occurred during execution: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Keep the main guard but simplify invocation
    # The SLURM script will directly call this main function
    main()